{"version":3,"sources":["component/lifecycles.component.jsx","component/clicks.component.jsx","async.js","App.js","serviceWorker.js","index.js","logo.svg"],"names":["Lifecycles","console","log","nextProps","nextState","text","this","props","className","React","Component","Clicks","clicks","lastUpdated","promiseFunction","fetch","then","userResponse","json","users","firstUser","id","postsResponse","posts","catch","error","asyncFunction","a","user","secondUser","postResponse","noFunctionSynchronizaton","thirdUser","App","formatDate","dateValue","current_datetime","Date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","toggleHeader","setState","showHeader","state","handleClicks","prevState","prevProps","increment","now","callPromiseAndAsynch","meaningOfLife","pageLoaded","src","logo","alt","onClick","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","message","module","exports"],"mappings":"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","file":"static/js/main.897c5404.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nclass Lifecycles extends React.Component {\r\n  constructor() {\r\n    super();\r\n    console.log('Lifecycles constructor!');\r\n  }\r\n\r\n  componentDidMount() {\r\n    console.log('Lifecycles componentDidMount!');\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    console.log('Lifecycles componentDidUpdate!');\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    console.log('Lifecycles componentWillUnmount!');\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps, nextState) {\r\n    console.log('Lifecycles shouldComponentUpdate?', nextProps);\r\n    return nextProps.text !== this.props.text;\r\n  }\r\n\r\n  render() {\r\n    console.log('Lifecycles render!');\r\n    return (\r\n      <div className='lifecycles'>\r\n        <h3>LIFECYCLES COMPONENT</h3>\r\n        {this.props.text}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Lifecycles;","import React from 'react';\r\n\r\nclass Clicks extends React.Component {\r\n  constructor() {\r\n    super();\r\n    console.log('Clicks constructor!');\r\n  }\r\n\r\n  componentDidMount() {\r\n    console.log('Clicks componentDidMount!');\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    console.log('Clicks componentDidUpdate!');\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    console.log('Clicks componentWillUnmount!');\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps, nextState) {\r\n    console.log('Clicks shouldComponentUpdate?', nextProps);\r\n    return nextProps.clicks !== this.props.clicks;\r\n  }\r\n\r\n  render() {\r\n    console.log('Clicks render!');\r\n    return (\r\n        <div>\r\n            # of Clicks: {this.props.clicks}<br/>\r\n            Last clicked: {this.props.lastUpdated}\r\n        </div>\r\n    );\r\n  }\r\n\r\n}\r\n\r\nexport default Clicks;","/*\r\n\r\nThe purpose of this javascript exercise is to demonstration a few ways to make \r\nmultiple asynchronous calls synchronous using the Promise or Async/Await methods\r\nprovided by javascript ES6 and ES7.\r\n\r\nTo use, copy and paste into browser javascript console and call each function.\r\n\r\nDetails:\r\n\r\nfetch() is an asynchronous global function. Calling fetch() returns a Promise. \r\nWe can then wait for the promise to resolve by passing a handler with the .then() \r\nmethod of the promise. That handler receives the return value of the fetch promise, \r\na Response object.\r\n\r\nIn the promiseFunction(), since fetch() returns a promise, we can use the \r\n.catch() method of the promise to intercept any error occurring during the execution \r\nof the request, and the processing done in the .then callbacks.\r\n\r\nIn the asynchFunction(), a try/catch format is used similar to Java. \r\nThe await keyword makes the thread wait for a response/reject from the method call \r\nto continue to the next line of code. If an error is thrown, it is caught\r\nby the catch portion.\r\n\r\n*/\r\n\r\nexport const promiseFunction = () => {\r\n\r\n\tfetch('https://jsonplaceholder.typicode.com/users')\r\n\t\t.then(userResponse => userResponse.json())\r\n\t\t.then(users => {\r\n\t\t\tconst firstUser = users[3];\r\n\t\t\tconsole.log(\"promiseFunction firstUser=\", firstUser);\r\n\t\t\treturn fetch('https://jsonplaceholder.typicode.com/posts?userId=' + firstUser.id);\r\n\t\t})\r\n\t\t.then(postsResponse => postsResponse.json())\r\n\t\t.then(posts => console.log(\"promiseFunction firstUser posts=\", posts))\r\n\t\t.catch(error => console.log(\"ERROR\", error));\r\n}\r\n\r\nexport const asyncFunction = async() => {\r\n\r\n\ttry {\r\n\r\n\t\tconst userResponse = await fetch('https://jsonplaceholder.typicode.com/users');\r\n\t\tconst user = await userResponse.json();\r\n\t\tconst secondUser = user[5];\r\n\t\tconsole.log(\"asyncFunction secondUser\", secondUser);\r\n\r\n\t\tconst postResponse = await fetch('https://jsonplaceholder.typicode.com/posts?userId=' + secondUser.id);\r\n\t\tconst posts = await postResponse.json();\r\n\t\tconsole.log(\"asyncFunction secondUser posts=\", posts);\r\n\r\n\t}\r\n\tcatch (error) {\r\n\t\tconsole.log(\"ERROR\", error);\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport const noFunctionSynchronizaton = () => {\r\n\r\n\t\tconst userResponse =  fetch('https://jsonplaceholder.typicode.com/users');\r\n\t\tconsole.log(\"userResponse\",userResponse); \r\n\t\tconst user = userResponse.json(); \r\n\t\t\r\n\t\t// userResponse.json is not a function error will be thrown because\r\n\t\t// promise retured by the fetch() function hasn't completed yet. \r\n\t\t// In the console you will see:  \r\n\t\t//\t\tuserResponse -> PromiseÂ {<pending>}\r\n\r\n\t\tconst thirdUser = user[3];\r\n\t\tconsole.log(\"noFunctionSynchronizaton thirdUser\", thirdUser);\r\n\r\n\t\tconst postResponse = fetch('https://jsonplaceholder.typicode.com/posts?userId=' + thirdUser.id);\r\n\t\tconst posts = postResponse.json();\r\n\t\tconsole.log(\"noFunctionSynchronizaton thirdUser posts=\", posts);\r\n\r\n}\r\n\r\n","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\nimport Lifecycles from './component/lifecycles.component';\n\nimport Clicks from './component/clicks.component';\n\nimport {promiseFunction, asyncFunction, noFunctionSynchronizaton} from './async.js';\n\n/*\nUpon \n*/\n\nclass App extends React.Component {\n\n  formatDate = (dateValue) => {\n    let current_datetime = new Date(dateValue);\n    let formatted_date = current_datetime.getFullYear() + \"-\" + (current_datetime.getMonth() + 1) + \"-\" + current_datetime.getDate() + \" \" + current_datetime.getHours() + \":\" + current_datetime.getMinutes() + \":\" + current_datetime.getSeconds();\n\n    return formatted_date;\n  }\n\n\n  constructor(props) {\n\n    console.log('App constructor!');\n\n    super(props);\n    this.state = {\n      meaningOfLife: \"Click Me & Toggle Header buttons show LifeCycle events in console.\",\n      lastUpdated: \"\",\n      clicks:0,\n      pageLoaded: this.formatDate(props.pageLoaded),\n      showHeader: true\n    }\n  }\n\n  componentDidMount() {\n    console.log('App componentDidMount!');\n  }\n\n  componentDidUpdate() {\n    console.log('App componentDidUpdate!');\n  }\n\n  componentWillUnmount() {\n    console.log('App componentWillUnmount!');\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('App shouldComponentUpdate!', nextProps);\n    return true;\n  }\n\n  toggleHeader = () => {\n\n    console.log(\"toggleHeader\");\n    this.setState({showHeader: !this.state.showHeader});\n  }\n\n  handleClicks = () => {\n\n    console.log(\"handleClicks\");\n\n    /*\n        \n    this.setState({clicks: this.state.clicks + 1, lastUpdated: formatted_date})\n    console.log(\"clicks:\", this.state.clicks);\n    console.log(\"lastUpdated:\", this.state.lastUpdated);\n    \n    This above code syntactically correct, but the setState() call is asynchronous, \n    so if you are excuting code after the setState() call, then it may be out of sync.\n    The console.log() calls may print out old data.\n\n    To remedy this, use call back functions in setState() as follows:\n\n    this.setState(\n     {clicks: this.state.clicks + 1, lastUpdated: formatted_date},\n     () => {\n        console.log(\"clicks:\", this.state.clicks);\n        console.log(\"lastUpdated:\", this.state.lastUpdated);\n     }\n    );\n    \n    Good article explaining this:\n    https://medium.com/better-programming/when-to-use-callback-function-of-setstate-in-react-37fff67e5a6c\n\n    */\n\n   /* \n    Best practice indicates to use a function call with (prevState, prevProps) parameters\n    to use the before and after values in the update. For example:\n  */\n    this.setState(\n      (prevState, prevProps) => {\n        //console.log(\"prevState:\", prevState);\n        return {clicks: prevState.clicks + prevProps.increment, lastUpdated: this.formatDate(Date.now())}\n      },\n      () => {\n        //console.log(\"clicks:\", this.state.clicks);\n        //console.log(\"lastUpdated:\", this.state.lastUpdated);\n      }\n   );\n\n\n  }\n\n  callPromiseAndAsynch = () => {\n    promiseFunction();\n    asyncFunction();\n  }\n\n\n  render() {\n\n    console.log('App render!');\n\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <h1>REACT CONCEPTS</h1>\n          <p><b>Snippets of code to demonstrate react concepts in action.</b></p>\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <br/>\n          <b>{this.state.showHeader ? <Lifecycles text={this.state.meaningOfLife} /> : ''}</b>\n          <p>PageLoaded: {this.state.pageLoaded}</p>\n          <Clicks clicks={this.state.clicks} lastUpdated={this.state.lastUpdated}/>\n          <br/>\n          <div className='buttons'>\n            <button onClick={this.handleClicks}>click me!</button> \n            <button onClick={this.toggleHeader}>toggle header</button>\n          </div>\n          <h3>Control Asyncronous Calls</h3>\n          <p><b>Click buttons below quickly to view synchronized calls to asyncronous functions in console.</b></p>  \n          <div className='buttons'>\n            <button onClick={promiseFunction}>Call promiseFunction Only</button>\n            <button onClick={asyncFunction}>Call asyncFunction Only</button>\n            <button onClick={this.callPromiseAndAsynch}>Execute Both</button>\n            <button onClick={noFunctionSynchronizaton}>No Synchronization</button>\n            \n            \n          </div>\n        </header>\n      </div>\n    );\n\n  }\n\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App increment={1} pageLoaded={Date.now()}/>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";"],"sourceRoot":""}